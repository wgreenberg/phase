<html>
<head>
<script>
async function loadBuffer(ctx, path) {
    const response = await fetch(path);
    const arrayBuffer = await response.arrayBuffer();
    const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
    return audioBuffer;
}

function createBufferSource(ctx, buffer) {
    let source = ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(ctx.destination);
    return source;
}

async function loadNotes(ctx, volume, notes) {
    return await Promise.all(notes.map(async (note) => {
        const buffer = await loadBuffer(ctx, `samples/${volume}/${note}.mp3`);
        return createBufferSource(ctx, buffer);
    }));
}

function cloneNote(note) {
    return createBufferSource(note.context, note.buffer);
}

function crossProduct(a, b) {
    return Array.from(b).flatMap(a_i => Array.from(a).map(b_i => b_i + a_i));
}

const N_PLAYERS = 2;
const PULSES_PER_MEASURE = 8; // eighth notes
const TICKS_PER_PULSE = 40;
const PULSES_PER_MINUTE = 80;
const NOTE_NAMES = crossProduct('CDEFGAB', '345');

class Player {
    constructor(notes, sequence) {
        this.notes = notes.map(cloneNote);
        this.sequence = sequence;
        this.tick_offset = 0;
        this.last_played_pulse = 0;
    }

    tick(t) {
        const adjusted_tick = t + this.tick_offset;
        if (adjusted_tick % TICKS_PER_PULSE == 0) {
            const pulse_number = (adjusted_tick / TICKS_PER_PULSE) % PULSES_PER_MEASURE;
            this.last_played_pulse = pulse_number;
            this.sequence[pulse_number].forEach(note_idx => {
                const note = this.notes[note_idx];
                this.notes[note_idx] = cloneNote(note);
                note.start();
            });
        }
    }
}

function readSequence(sequencer) {
    const sequence = Array.from({length: PULSES_PER_MEASURE}, () => []);
    sequence.forEach((_, measure_idx) => {
        Array.from(sequencer.rows).slice(1).forEach((row, note_idx) => {
            const input = row.cells[measure_idx + 1].firstChild;
            if (input.checked) {
                sequence[measure_idx].push(note_idx);
            }
        });
    });
    return sequence;
}

function sequenceToString(sequence) {
    return sequence.map(pulse => pulse.join(',')).join(';');
}

function sequenceFromString(input) {
    const sequence = input.split(';')
        .map(pulse => pulse.split(',').filter(n => n != '').map(n => parseInt(n)));
    if (sequence.length !== PULSES_PER_MEASURE && sequence[0].length !== NOTE_NAMES.length) {
        throw `invalid sequence ${sequence}`;
    }
    return sequence;
}

function buildSequencer(notes, measure_length, players, sequence) {
    const table = document.getElementById('sequencer');
    const player_row = document.createElement('tr');
    player_row.id = 'players';
    for (let i=0; i < PULSES_PER_MEASURE + 1; i++) {
        player_row.appendChild(document.createElement('td'));
    }
    table.appendChild(player_row);
    notes.forEach((note, noteIdx) => {
        const row = document.createElement('tr');
        const header = document.createElement('th');
        header.innerText = note;
        row.appendChild(header);
        for (let pulseIdx=0; pulseIdx < measure_length; pulseIdx++) {
            const cell = document.createElement('td');
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.checked = sequence[pulseIdx].includes(noteIdx);
            cell.appendChild(input);
            row.appendChild(cell);
        }
        table.appendChild(row);
    });

    const inputs = Array.from(document.getElementsByTagName('input'));
    inputs.forEach(input => input.addEventListener('change', () => {
        const sequence = readSequence(document.getElementById('sequencer'));
        window.location.hash = `#${sequenceToString(sequence)}`;
        players.forEach(player => player.sequence = sequence);
    }));
}

function updatePlayerRow(players) {
    const last_played_pulses = Array.from({length: PULSES_PER_MEASURE}, () => []);
    players.forEach((player, i) => last_played_pulses[player.last_played_pulse].push(i));
    const row = document.getElementById('players').cells;
    Array.from(row).slice(1).forEach((pulse_td, i) => {
        pulse_td.innerText = last_played_pulses[i].join(',');
    });
}

window.addEventListener('load', async () => {
    const ctx = new AudioContext();
    const notes = await loadNotes(ctx, 'ff', NOTE_NAMES);
    let sequence = Array.from({length: PULSES_PER_MEASURE}, () => []);;
    if (window.location.hash.length > 0) {
        try {
            sequence = sequenceFromString(window.location.hash.substr(1));
        } catch (e) {
            console.log(`failed to parse sequence in url: ${e}`);
        }
    }
    const players = Array.from({length: N_PLAYERS}, () => new Player(notes, sequence));
    buildSequencer(NOTE_NAMES, PULSES_PER_MEASURE, players, sequence);

    const ticks_per_minute = TICKS_PER_PULSE * PULSES_PER_MINUTE;
    const ms_per_tick = (1 / ticks_per_minute) * 60 * 1000;
    const ticks_per_measure = TICKS_PER_PULSE * PULSES_PER_MEASURE;
    let t = 0;
    setInterval(() => {
        players.forEach(player => player.tick(t % ticks_per_measure));
        if (t % ticks_per_measure == 0) {
            players.forEach((player, i) => player.tick_offset += i * TICKS_PER_PULSE);
        }
        updatePlayerRow(players);
        t++;
    }, ms_per_tick);
});
</script>
</head>
<body>
<table id='sequencer'></table>
</body>
</html>
